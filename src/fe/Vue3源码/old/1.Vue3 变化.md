---
category:
  - 前端
  - Vue
tag:
  - 珠峰架构
---

# Vue3 变化

## 区别介绍

- 源码采用 `monorepo` 方式进行管理，将模块拆分到package目录中。

  Vue2 项目包含很多包，但这些包都在同一个仓库下管理。vue2这种形式在项目复杂或需要更多扩展的时候，变的非常复杂。例如 vue2 源码项目中包含 weex 内容，如果我们想要增加一些新的模块，如 mpvue，就需要在 vue2 源码基础上进行修改。

  Vue3 采用 `monorepo` 的方式，一个仓库下有多个包，可以只使用某一个模块，比如说响应式模块。如果只需要去做编译流程，可以专门去引它的编译模块。package 下有多个包，每个包都包含自己的package.json，可以单独打包，单独发布。这样的话，如果要基于某个模块去扩展，只需要把这个模块引进来，并不需要在它的原有基础上去更改代码。而且模块儿之间，也可以相互引用。

- ﻿﻿`Vue3` 采用`ts`开发,增强类型检测。 `Vue2` 则采用`flow`，flow 不再更新且类型推断较差，有很多推断不出来。

- `Vue3`的性能优化，支持tree-shaking, 不使用就不会被打包。

- `Vue2` 后期引入RFC , 使每个版本改动可控 [rfcs](https://github.com/vuejs/rfcs/tree/master/active-rfcs)。

  内部代码优化

- `Vue3` 劫持数据采用proxy `Vue2` 劫持数据采用`defineProperty`。 `defineProperty`有性能问题和缺陷
- `Vue3`中对模板编译进行了优化，编译时 生成了Block tree，可以对子节点的动态节点进行收集，可以减少比较，并且采用了 `patchFlag` 标记动态节点 jsx
- `Vue3` 采用`compositionApi` 进行组织功能，解决反复横跳，优化复用逻辑 （mixin带来的数据来源不清晰、命名冲突等）, 相比`optionsApi` 类型推断更加方便
- 增加了 `Fragment`,`Teleport`，`Suspense`组件



> OK啊，完了我先欢迎大家呢，参加我们珠峰架构师政治课第一天啊，完了咱们呢，今天呢，主要就讲这个vivo vivo 3的一个构建流程。还有我们view 3的，它的详细原理，这个模块儿我们会带大家去手写一下，完了大概的这个近期的课程安排呢，大家可以去看一下这个我这样一个计划啊。完了，基本上相差不差呃，基本上都会讲到，但是可能上进度上可能会有一些略微调整，大家可以自己去看一下啊。啊，包括我会及时更新文档，我到时候视频呢，还有我们的这个代码呀，会提到这个仓库里面，我在群里面也发了啊，大家可以自己去找一下。完了呢，咱们先去谈一谈吧，这个view 3和view 2的一个区别，因为很多人发现哎，不是市面上用的最多的还是view 2吗？那你为什么要讲这个view 3呢？是吧？咱们第一呢，咱们是学技术的是吧？咱们要保持这个技术的，这个新鲜是吧？我们需要掌握第一手新鲜的资源。所以呢，我们现在要掌握这个view 3，而且啊，在不久的将来，你回view 3呢，你会发现目前你去面试啊，你会view三会比就只干干会view 2。是不是强很多呀？而且面试官也会觉得噢，你是在追追求这个新的技术，那问题就出现了。那为什么我们要去掌握六三？为什么要学习六三？对吧？它有哪些好处？比view 2优优点在哪？是吧？那咱们先来说一说啊，第一呢，我们view 3的源码呢，它采用了这种module ripple的方式呢，进行管理了。哎，什么叫model ripple呢？我们都知道啊，以前的vr项目，哎，咱们可能当一个vr项目，你发现呢vr呢，整个的一个框架呢，里面包含了很多包。那这些包呢？都在一个仓库下所管理啊，这是一个特点啊，就是相当于一个项目一个仓库。但是呢，我们发现如果项目复杂的时候，包括我们想更多的扩展的时候，发现非常复杂，我们可以看到vor的项目里啊。它其实呢，里面包含了wix的项目，是不是我们如果想基于vio 3呃vio 2去改版，那我们呢？比如说增加一些新的模块，比如像mp vo啊，像vix啊。这些东西，那我们需要直接在view 2的源码基础上去更改，但是呢，我们view 3呢，它呢，采用了这种model ripple的方式。也说我们一个仓库下呀，有多个包，我们这多个包呢，可以怎么样可以分呃分别发布到不同包里面，比如说我可以只使用某一个。某一个模块，比如说响应式模块，我可以只使用它的r哎，到时候咱们可以看到啊，我要比如说我们只需要去做它的这个编译流程，那好了，我们有可以专门去引它的编译模块。
> 这是它的好处，所以呢，当我们会看到啊，我们去构建这个模块儿的时候，我们会把它放到一个package目录下，里面有很多模块儿。呃，这里面儿可以给大家看一眼，这是我当下一个663的项目，这里面儿你看它把所有的模块儿呢放到一个package下了，里面儿有分别各自的模块儿。完这些各自的模块呢，都是一个单独的包，每个包里面都有一个，他可以单独打包，单独发布。这样的话呢，我们只需要考虑什么呀？是不是？比如说我要基于某个模块去扩展，那好了，我需要把这个模块引进来，并不需要在它的原有基础上呢？去更改代码。而且模块儿之间呢，也可以相互引用，这是我们的猫推后的一个方式啊，到时候咱们去写的时候会有更有感触是吧，感觉一下啊。好，而且呢，我们view 3呢，还采用了这个ts开发，哎ts呢，它我们都知道是吧，现在目前是一个比较主流的一个。的一个例行检例行检测的一个方案了，那我们用它呢？你会发现会怎么样？代码提示会非常强。所以view 3呢，整个呢，它把源码呢都采用ts来开发，哎，这个后面咱们会讲ts啊，大家不用担心，今天虽然会给大家去搭建这个贴字环境。但是咱们写代码的时候呢，不会去把这个很大多数的这个焦点放在这个ts上啊，完了呢，我们view 2呢，采用的是flow。像flow的推断呢？它其实呢，并不准确，比如说有很多东西推断不出来，但是ts呢，相对flow呢，会更好一些，而且flow呢，现在也不再更新了啊。所以说我们也要从这个呃view 2 good到view 3，你还是需要掌握一些ts的，但是在我们开发环境下呢，其实你不是非得用这个ts，但是呢，目前来说ts。ts也是非常重要的，是这样的啊。好了，那除了这个之外呢？我们view 3呢？它的性能呢？优化是非常强的，因为它支持了我们这种所谓的tree shaking。我们view 3呢，它都是这种所谓的函数，对我们写的都是一个个的函数，那这样的好处就是我们可以呢，根据我们引用的函数呢，去知道我们需要用到哪些包。哪些方法这样呢？可以方便我们的垂线性。
> 像以前我们用view 2的话，咱们view 2是不是都把一些配置啊放到一个对象里面那view呢？是没法知道我们哪些东西是不需要的，哎，可能我多写了几个方法。但是view不知道这方法是没有用的哎，所以呢，我们view 3呢，也支持了这种tree setting，这是它的好处。还有就是我们view 2后期呢，它引入这种rfc哎，这rfc大家都听过是吧，就是我们可以让大家可以去讨论啊，说新增哪些功能，咱可以看一下啊，这是它的文档。我在这里面新建一个啊。你看一下这里面呢，包含着所有人提的意见哎，包括呢，我们view 3在实现的时候也是遵循了这个lc。就是相当于我们所有的实现功能啊，都经过很多人的去讨论完了，这样的话呢，才定版的，比如说像我们的这种composition API。啊view3里面一个特性是吧，你看这里面就是之前讨论的，那里面有很多啊，包括怎么去实现对大家可以去看这个文档呢？知道view 3有哪些更新？我后续要更新什么，这是它的好处。那咱们还是要落实到这个代码上是吧？代码层面上那咱来看看这个view 3呢和view 2代码上有什么区别？我看看大家的问题，哎，瞄一眼啊。好呃，是不是有时候声音刺耳的声音应该不会吧，自己调整一下啊，因为这个麦克风我是新换的啊。好，完了这里面再来看看内部代码的优化。呃，我看看啊，第三方库呃ts项目怎么调试？你可以去加source map一样的啊，一样的。有杂音呃，我调整一下啊，应该不会。呃，我看着还好啊，我不行，到时候再调整一下吧。
> 是什么意思呃，叫request for？我就是相当于你这里面有写啊，大家如果想知道它这里面有写在这个里面啊，我后退一下。它就是一个你可以认为就是大家在里面去交流完了，最后呢，再去定稿完了，就根据他的这个激活的IOC呢，去实现我里面有写啊，这IOC干嘛的哦，我就不去没有写呢，叫required for commence是吧？就是所有的意见他都会在这里面。大家可以去提交意见，在里面，只要意见通过了，他就会去实现对应的方法是吧？而且view 3在实现的时候呢，也是遵循着这些提供的FC啊，是这样的。好，那这里面呢？我们回过来啊，咱还是主要看一下这个呃view 3和view 2在代码层面上的一个变化，这咱更更加关心不并不是说它有哪些优点是吧？光说肯定不行。咱要知道它内部哪些东西增强了。我们view 3呢，它整个的数据劫持呢，采用了proc y，我们都知道啊，view 2呢，它采用的是d。哎，以前面试经常问的一个问题，就是啊，view 3和view 2这个显示的区别那view view 2呢？它采用的是def in party。它呢，会把一个对象呢，完整的递归完了，给每个属性增加get和set。呃，第一啊，它完整递归这个性能很差，第二呢，我们还要给每个属性去增加get set这个性能呢，也不高。所以呢，这也就是我们view2里面这个想要是数据多了以后啊，会有很多问题是吧，就是它还是会有呃，比如说它会有一个深度便利的过程，会有卡顿的过程。所以呢，我们view 3呢，它采用了这个process，这个process呢，是一个天然的拦截器，它的性能呢，比我们的v2好很多，它并不需要呢去。去改写属性的get set啊，它不需要，就是把原来属性重新定义，这是它的优势。第二呢，它也不用一上来呀，就全部递归了，比如说我有个对象，那对象里面可能有很多层，只有当我们取到某一层的时候，我们再去使用这个pro。经代理啊，这是我们一个核心的一个提升，对吧？比如六三里面主要靠提升就是一个，其中一个就是这个。policy咱们今天也是会详细去讲它是怎么做代理的。还有普通数据怎么做的？包括view3里的计算属性，还有它的watch API等等啊，咱们都会讲到。
> 再就是呢，view3里面呢，它还采用了这个模板编译的优化，哎，这个模板编译啊，这个优化其实做的已经非常好了。比我们的vo 2好很多，你像我们vo2里面，它也会有这样一个优化过程，比如说它会判断啊，这个父结点呀，是不是一个静态结点？如果是静态结点的话，好了我就不去对比它了，但是这个呢，其实还是相当于要怎么样，要遍历整棵树。你像我们那个地图算法是一棵树，树和树的比较，但是呢，我们这种情况呢，没法避免这个树的便利。但是在view3里面呢，他对这个模板编译其实做了很多事儿啊，因为咱后面这个不是一两句话能说清楚的，咱们后面呢，会单独去讲这个啊。呃，手写它的想啊，这个编译原理我要看看编译里面做了什么事儿啊，它会它会做什么呀，它会生成一个东西叫block tree。这个block tree呢？它会描述，比如说一个标签里，这个标签里面呢有很多动态的属性，比如有个p标签里面放了个文本，这个文本是动态的。好，它会单独把这个动态东西怎么样？提取出来后啊，提取到一个数组里，数组里面放着当前标签下所有动态的什么？一些内容这样，我在比较的时候呢，我只需要比比较这个动态的部分，而且呢，他对这个动态的部分呢，也标记了。比如说是类的标啊类的一个动态还是样式的一个动态，还是我们的文本的动态等等。哎，所以这里面它还采用了，这也是它的一个性能优化的一个提升，而且在在我们view 3的编译层里面呢，这个代码明显也会比view 2。多了很多啊，而且更复杂一些是吧，完了我们都说了啊，那这两个是我们一个view 3的核心优化点。哎，我看看呃，裁剪这个地址，到时候我看看能不能打成PDF发给大家啊？好，那我们view 3呢？它呢？采用了我们的com papi，而且这也是我们的一个核心亮点是吧？我们都知道噢，view 3的核心以前叫。options API就是我们写view的时候呢，会提供一个对象，而这个对象里面呢，可能放上什么data呀computed呀watch啊？
> 那我们写一个功能的话，我需要把这一个功能拆分到不同的位置，哎，这就会出现个问题啊，如果功能非非常多，那我们要反复的怎么样？是不是你看一个computer的写了100行？一个watch写的100行，那我们要不停的上下去跳，而且是一个功能，我拆分到了不同的方法里，这是他的一些。缺陷是吧？而且呢，我们把这些方法放到了我们的实例上，这样的话呢，我们想推断它的具体类型也非常复杂。哎，包括我们都知道这个view 2，它对这个ts的支持并不好，但是view 3就不一样了是吧？那view 3呢？它采用了这种composition API。进行了这种组织，哎，那组织代码，那代码组织好以后怎么样？我们可以把复用的代码抽成一个个的函数，或者我们可以叫做hook是吧啊，抽出一个个的函数。之后呢？在不同的地方，怎么样去引入这个函数？哎，那这样的话呢，我们可以方便代码组合，而且我们可以把某一个功能封装到不同的函数里，不是一个功能放到一个函数里，一个功能放到一个函数里。这样就避免了，我们反复横跳的问题相当于我们可以把一个功能放到一起，而不是把它拆散到不同的逻辑里去。这也是它的一个优点。完了，再就是呢，我们特点就是什么是增加了一些像right相关的right里面有以前说一个组件，里面只能有一个根元素，就是view的特点。但是现在呢，它也支持了这种fragment啊，相当于在外层呢，套了一个虚拟的节点啊，包括呢，它也支持了我们这种teleport。就是我们所谓的传送，是吧？我们可以自己去把一个组件传送到不同的地方去渲染，还有呢，我们的一些异步组件，比如说像这种s我们。我们可以等待组件加载完，我要去加载之中显示一些楼顶这样一些效果。好啦，这是我们view 3的一些核心特性，我们在后面的学习中呢，比如学习到某个点。会详细的再去深入大家要先知道这些特性，这也是面试里面必问的，就算你不会源码，你也得知道哦，它有哪些改动？是这样的啊。
> 好呃，view 3的复用是什么呀？除了VC e啊，我们可以采用什么？是不是composite是API啊？我们可以把公共的逻辑抽成一个方法。在不同的地方去使用，像我们你说的这个miss in，它有很多问题啊，因为我们可能在负集里面，是不是啊？弄一个miss in数据完了完了，插入到子集里面。那问题就是数据来源不明确，因为我不知道这个数据从哪来的啊？可能是全局来的，可能是自己当前组件挡进来的。那可能呢？数据来源不清晰，而且呢，可能这个名字呀，和我当前组队的名字有冲突。但是如果我们把这功能封装成一个函数，那我要解决这种什么命名冲突啊，更加容易了，我可以用这个冒号的方式去改写它的名字。是这样的啊，所以说view 3呢，它复用主要也是借助了这个composition API的一个能力。是这样的啊，好ref咱今天会说好吧，比如ref呢，是让一个普通数据类型变成显示的。那writing呢？它是让一个直接是一个对象，比如我的数据很复杂，我可以直接采用writing，它可以直接让这个对象被拦截。这两种方案啊，而且ref呢，它底层采用的是def in party，完了我们的writing，它采用的就是我们的process啊，不太一样。为什么要研究数据来源？因为我要知道，这个数据从哪来的？比如说我在写代码的过程中，突然来了个变量，这变量哪来的呀？是不是我就得找啊？从哪来的吧？而且这变量哪来的时间？什么功能？那如果在多人开发中，是不是也很痛苦？是吧，好。啊，可以获取节点对好这个set up方法哦，撤回了吗？呃，主要是在跟组件项目，任何地方都可以调用，对每个组件它都提供了set up。teleport叫传送框，什么叫传送框呢？就是我可以把某个组件完了，传送到某个地方去渲染，比如说我们写个弹层组件。那这个弹层肯定是个全局组件吧，那我就可以采用这个teleport。
> 这件事儿了啊，好完了，这里面我瞄一眼，那就是普通数据类型，用ref复杂数据用writing对是这样的。是这么是这么规划的啊好。嗯，声音都正常吗？我确认一下啊。呃，类似于对portal对其实都是借鉴了rewrite的一些思想，是这样的啊，好相当于挂在了object pro type上，是不嗯跟object pro type有啥关系？好吧，这个没关系啊，对传送门对red传送门一个意思啊teleport。好好了，这里怎么卡都看不到？嗯，不会啊，看看自己是不是自己的问题啊？vivo 3接下来是不是很爽呃，感觉很像react，但是不太一样。因为composition API，它的特点是靠响应式原理，但是right呢是靠每次的render，这是有区别的啊。好，那这里我先保存一节啊，保存一节嗯，不爽那是没。
